---
title: "TD2 à rendre"
author: "Erwan Judic, Barbier--Darnal Joseph"
output: html_document
---

```{r echo=TRUE, message=FALSE, warning=FALSE}
rm(list=ls())
setwd("/Users/josephbarbier/Desktop/M1S2/stats computationnelles")
library(FactoMineR)
library(factoextra)
library(stats)
library(ggplot2)
library(hrbrthemes)
library(RColorBrewer)
library(maps)
```






# Exercice 2

### Open file

```{r}
df = read.table("fromage.txt", header = TRUE, row.names = 1)
head(df)
```





\
<br>

### Standardize data

```{r echo=TRUE, message=FALSE, warning=FALSE}
#uncorrected variance
n = nrow(df)
correction = sqrt((n-1)/n)
std = function(vec){
  return(sd(vec)*correction)
}

#center
df_norm = scale(df, scale=FALSE)

#reduce
stds = apply(df, 2, std)
for (i in seq(1,ncol(df))){
  df_norm[,i] = df_norm[,i] / stds[i]
}

#convert to dataframe
df_norm = as.data.frame(df_norm)

apply(df_norm, 2, std)
round(apply(df_norm, 2, mean))
```



\
<br>

### ward's CAH

```{r echo=TRUE, message=FALSE, warning=FALSE}
d = dist(df_norm)
n = nrow(df_norm)
tree = hclust(d^2/(2*n), method="ward.D")
k = 5
group_labels_ward = cutree(tree, k = k)
df_norm$group = group_labels_ward
```




\
<br>

### Explained inertia

```{r echo=TRUE, message=FALSE, warning=FALSE}
explained_inertia = sum(sort(tree$height, decreasing = TRUE)[1:k-1])/sum(tree$height) *100
cat("Percentage of explained inertia (ward's CAH, with k =", k, ")", round(explained_inertia,2), "%")
```




\
<br>

### K-means

```{r echo=TRUE, message=FALSE, warning=FALSE}
k_means = function(k, df=df_norm[1:9], nstart=1){
  kmeans = kmeans(df, k, nstart=nstart)
  explained_inertia = kmeans$betweenss/kmeans$totss*100
  cat("Percentage of explained inertia (k-means, with k =", k, ")", round(explained_inertia,2), "%\n")
}

k_means(5)
```





\
<br>

### Multiple k-means

```{r echo=TRUE, message=FALSE, warning=FALSE}
k_means(5, nstart = 10)
```

Le pourcentage d'inertie expliquée change en re-exécutant l'algorithme des k-means, pour un k fixe. Cela est dû au fait que la première partition, à l'étape 1 de l'algorithme, est aléatoire, amenant l'algorithme à converger vers différents extrema locaux en fonction de cette initialisation.

Afin de trouver un meilleur extremum local, on peut fixer la valeur de l'argument `nstart` en la mettant plus élevée. En faisant cela, on fait tourner l'algorithme *nstart-fois* et on garde la partition avec la plus grande proportion d'inertie expliquée. 






\
<br>

### Best clustering method

Dans notre cas, la meilleure méthode de partitionnement en 5 classes est celle des k-means puisqu'elle maximise davantage notre critère d'inertie inter-classe.





\
<br>

### Table

```{r echo=TRUE, message=FALSE, warning=FALSE}
kmean = kmeans(df_norm[1:9], 5, nstart=10)
group_labels_kmeans = kmean$cluster
table(group_labels_kmeans, group_labels_ward)
```

La fonction `table` nous permet de voir la différence de réparition parmi les deux méthodes de partitionnement utilisée. Dans notre cas, on retrouve 2 individus qui diffèrent entre les partitions proposées.  







\
<br>
\
<br>

# Exercice 4

```{r}
df = read.table("urbanGB.txt", sep = ",", dec=".", header = FALSE)
colnames(df) = c("longitude", "latitude")
head(df)
```


\
<br>

### Scatter plot

```{r echo=TRUE, message=FALSE, warning=FALSE, fig.align='center', fig.width=4, fig.height=5}
ggplot(df, aes(x = longitude, y = latitude)) + geom_point() + theme_classic()
```





\
<br>

### Clustering

```{r echo=TRUE, message=FALSE, warning=FALSE, fig.align='center', fig.width=4, fig.height=5}
#kmeans and centroids
kmeans_result = kmeans(df[,c("longitude","latitude")], centers=1000, iter.max=20)
centers = aggregate(df[,c("longitude","latitude")], by = list(cluster = kmeans_result$cluster), FUN = mean)
centers$weight = kmeans_result$size / nrow(df)

#ward algorithm
dist_matrix = dist(centers[, c("longitude", "latitude")])
ward_result = hclust(dist_matrix, method = "ward.D")
partition = cutree(ward_result, k = 10)

#plot new graph
ggplot(centers, aes(x = longitude, y = latitude)) + geom_point(col=partition) + theme_classic()
```





\
<br>

### England map

```{r echo=TRUE, message=FALSE, warning=FALSE, fig.align='center', fig.width=4, fig.height=5}
worldmap = map_data('world')
carte = ggplot() +
  geom_polygon(data = worldmap, aes(x = long, y = lat, group = group),
               fill = 'gray90',color = 'black') +
  coord_fixed(ratio = 1.3,  xlim = c(-10,3), ylim = c(50, 59)) +
  theme_void()
carte
```







\
<br>

```{r echo=TRUE, message=FALSE, warning=FALSE, fig.align='center', fig.width=7, fig.height=8}
carte = ggplot() +
  geom_polygon(data = worldmap, aes(x = long, y = lat, group = group),
               fill = 'gray90',color = 'black') +
  coord_fixed(ratio = 1.3,  xlim = c(-10,3), ylim = c(50, 59)) +
  theme_void() +
  geom_point(data = centers, aes(x = longitude, y = latitude, color = as.factor(partition)), alpha = 0.6, size = 1.5)
carte
```








\
<br>
\
<br>
\
<br>
\
<br>
\
<br>
\
<br>
